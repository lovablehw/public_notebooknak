name: Publish to public repo (Consolidated)
on:
  workflow_dispatch:
    inputs:
      target_branch:
        description: 'Target branch in public repo (usually main)'
        required: false
        default: 'main'

jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Determine Refs
        id: refs
        run: |
          SHORT_SHA=$(echo "${GITHUB_SHA}" | cut -c1-7)
          echo "publish_branch=publish-$SHORT_SHA" >> $GITHUB_OUTPUT
          echo "target_branch=${{ github.event.inputs.target_branch }}" >> $GITHUB_OUTPUT

      - name: Push to Public Repo
        env:
          PUBLIC_REPO_TOKEN: ${{ secrets.PUBLIC_REPO_TOKEN }}
          TARGET_REPO: "lovablehw/public_notebooknak"
        run: |
          set -euo pipefail
          PUBLISH_BRANCH="${{ steps.refs.outputs.publish_branch }}"
          
          # Setup non-interactive Auth
          ASKPASS_FILE="$(mktemp)"
          printf '#!/bin/sh\nprintf "%%s\\n" "$PUBLIC_REPO_TOKEN"' > "${ASKPASS_FILE}"
          chmod +x "${ASKPASS_FILE}"
          export GIT_ASKPASS="${ASKPASS_FILE}"

          # Push the code as the new publish branch
          git -c credential.username=x-access-token push --force "https://github.com/${TARGET_REPO}.git" "HEAD:refs/heads/${PUBLISH_BRANCH}"
          rm -f "${ASKPASS_FILE}"

      - name: PR or Initialize
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.PUBLIC_REPO_TOKEN }}
          script: |
            const [owner, repo] = "lovablehw/public_notebooknak".split('/');
            const head = "${{ steps.refs.outputs.publish_branch }}";
            const base = "${{ steps.refs.outputs.target_branch }}";
            
            try {
              // 1. Try to fetch the 'base' (main). If this fails, we go to the catch block.
              await github.rest.repos.getBranch({ owner, repo, branch: base });
              
              // 2. If 'main' exists, check for an existing open PR
              const { data: prs } = await github.rest.pulls.list({ owner, repo, state: 'open' });
              const existing = prs.data.find(p => p.head.ref === head && p.base.ref === base);
              
              if (existing) {
                await github.rest.pulls.update({ owner, repo, pull_number: existing.number, title: `Update from Private Repo` });
                console.log(`Updated PR #${existing.number}`);
              } else {
                const pr = await github.rest.pulls.create({ 
                  owner, repo, base, head, 
                  title: `Publish from Private Repo`,
                  body: `Syncing code to ${base}.` 
                });
                console.log(`Created PR #${pr.data.number}`);
              }
            } catch (e) {
              if (e.status === 404) {
                // 3. If 'main' doesn't exist, create it using the code we just pushed
                console.log(`Target branch "${base}" not found. Initializing repo...`);
                const { data: refData } = await github.rest.git.getRef({ owner, repo, ref: `heads/${head}` });
                await github.rest.git.createRef({
                  owner, repo,
                  ref: `refs/heads/${base}`,
                  sha: refData.object.sha
                });
                console.log(`Successfully initialized "${base}" branch.`);
              } else {
                throw e;
              }
            }
